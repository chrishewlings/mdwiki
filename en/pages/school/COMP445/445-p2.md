## Transport layer 

### Pipelining

#### Go-Back-N

- Sender: 
	+ up to `n` unACKed packets
	+ keeps timer for oldest unacked packet
	+ when timer expires, retransmit all unACKed packets
- Receiver: 
	+ Only sends **cumulative ACK** if no gaps, otherwise doesn't send

![Go-Back-N](./go_back_n.png)


#### Selective Repeat

- Sender: 
	+ up to `n` unACKed packets
	+ Maintains timer for each packet
	+ Retransmits unACKed packet only
- Receiver: 
	+ individual ACK for each packet

![Selective Repeat](./selective_repeat.png)

WARNING: Window size <= 0.5*maximum sequence number

### TCP

Properties:
    - 1 sender <=> 1 receiver
    - Bytestream (no boundaries)
    - Pipelined
    - Full duplex
    - Connection-oriented
    - Flow-controlled
    - Fair: congestion control throttles rate

- **Acknowledgements**: sequence number of next byte expected from other side
- Implementor defines handling OoO segments

![TCP Sequence numbers](./tcp_sequence_numbers.png)

#### RTT, Timeout

- Timeout **too short**: premature timeout, unnecessary retransmissions
- Timeout **too long**: slow reaction to segment loss

- **SampleRTT**: measured time from segment transmission until `ACK`
- **EstimatedRTT**: \\( 1- \alpha \) \times EstimatedRTT + \alpha \times SampleRTT \\), typically **0.125**
- **DevRTT**: \\(1- \beta ) \times DevRTT + \beta \times | SampleRTT - EstimatedRtt| \\), typically **0.25)
- **TimeoutInterval** \\( = EstimatedRTT + 4\times DevRTT\\)

#### Reliable Data Transfer

- **Fast Retransmit**: if sender receiver 3 `ACK` for same data, resent unACKed segment with smallest sequence number

#### Flow Control

- Receiver advertises free buffer space in `rwnd` value
- Sender limits amount of unACKed data to `rwnd` value

#### Handshake

- 2 way handshake fails b/c:
    + variable delay
    + message loss
    + message reordering

![Three Way Handshake](./three_way_handshake.png)

#### Closing

- Client, server each send TCP segment with `FIN` bit on
- Respond to `FIN` with `ACK`

![TCP Closing Connections](./tcp_close_connection.png)

#### Congestion

- Output link capacity: \\(R\\)
- when arrival rate approaches capacity, \\( R \rightarrow \infty \\)
- Handling congestion:
    + **Additive increase**: increase `cwnd` by 1 MSS
    + **Multiplicative decrease**: cut `cwnd` in half after every loss

##### Slow Start

- Double `cwnd` every RTT
- **Loss by timeout**: 
    + Reset `cwnd` to 1 MSS
    + Grow window **exponentially** until **threshold**, then **linear**
- **Loss by 3xACK**:
    + `TCP RENO`
    + Cut `cwnd` in half, regrow **linear**
- **TCP Tahoe**:
    + Always sets `cwnd` to 1, whether timeout or 3x`ACK`
- Switch exponential to linear when `cwnd` gets to **half** of value before timeout

##### Throughput

- \\(W\\): window size
- Average TCP throughput: \\( \frac{3}{4} \frac{W}{RTT} bytes/sec \\)
- Throughput in terms of segment loss probability: \\( \frac{1.22 \times MSS}{RTT \sqrt{L}} \\), needs very low loss rate

## Network Layer

- Roles:    
    + **Forwarding**: move packets from input to appropriate output
    + **routing**: determine route taken by packets from source -> destination
- Transport segment from sending to receiving host
- **sender**: encapsulate segment into **datagrams**
- **receiver**: deliver segment to transport layer

### Data Plane

- Local, **per-router**
- Determine how datagram is forwarded from input to output

### Control Plane

- **Network-wide** logic
- Determine how datagram is routed among routers
- **traditional routing algorithms**: implemented in **routers**
- **Software-defined networking**: implemented in **servers**
- A **logically centralized** control plane has a distinct **controller** (control plane) interacting with local **control agents** (data plane)

### Service models

![Network Service Models](network_service_models.png)

### Router architecture

- **Routing/management control plane**: software, ms time frame
- **Forwarding data plane**: hardware, ns time frame
- **Destination-based forwarding**: forward based on destination IP
- **Generalized forwarding**: forward based **any header field values**

#### Longest Prefix Matching
- When looking for forwarding table entry for given destination, use **longest address prefix** that matches destination
- Uses **ternary content addressable memories**; retrieves address in \\(O(1)\\) time

#### Switching Fabrics

![Switching Fabrics](./switching_fabrics.png)
- **Switching rate**: switching rate of \\(N\\) times line rate desirable
- **Memory**:
    + Switching controlled by CPU
    + packets pass through system memory, so speed limited to memory bandwidth
- **Bus**:
    + Shared bus moves input->output
    + Limited by bus bandwidth (contention)
    + 32Gbps 
- **Interconnection network**:
    + Banyan, crossbar topologies from developments in multiprocessor designs
    + fragment datagram into fixed length cells
    + 60Gbps

##### I/O Queuing

- **Input**: 
    + **Head-of-line blocking**: queued datagram at front prevents others from moving forward
- **Output**:
    + **buffering** required from fabric faster rate, else packet loss due to congestion/overflow
        + traditional avg buffer: \\(RTT_{typical} \times LinkCapacity \\)
        + Modern avg buffer: \\(\frac{RTT \times LinkCapacity}{\sqrt{N}} \\)
    
##### I/O Scheduling
- **discard policy**: which packet to discard if queue is full?
    + tail drop (arriving), priority, random
- **Round Robin**
    + multiple scheduling classes
    + cyclically scan class queues, sending one complete from each class
- **Weighted Fair Queueing**:
    + generalized RR
    + Each class gets weighted amount of service per cycle
    
### IP

- TCP + IP = 40 bytes overhead
- Networks have maximum transfer unit (MTU) so datagrams may be fragmented, reassembled
![IP fragmentation,reassembly](./ip_fragmentation.png)

#### IPv4

![Classful Addressing](./classful_addressing.png)
- Devices in same **subnet** can reach each other without intervening router
- ISP gets a block of IPs from ICANN
- Hierarchical addressing allows efficient advertising of routing information
- **CIDR Notation**: `a.b.c.d/x`, x=subnet portion of arbitrary length
![CIDR](./cidr.png)

##### DHCP

- Connection:
    - Client broadcasts `DHCP DISCOVER` \[optional\]
    - DHCP server responds with  `DHCP OFFER` \[optional\]
    - Client requests IP  `DHCP REQUEST`
    - DHCP server sends address `DHCP ACK`
- Other DHCP transmitted info:
    + Address of first-hop router
    + name/IP of DNS server
    + subnet mask

##### NAT

- WAN side address has ~60000 simultaneous connections
- Violates end-to-end argument
- Violates layers: routers should only process up to layer 3

#### IPv6

- Fixed 40 byte header, 128 bit addresses
    + **adds**: priority, flow label, next header
    + **removes**: options (now outside of header)
    + ICMPv6
- IPv6 packets can be tunneled over v4

#### Forwarding, SDN

- Each router has a **flow table** computed and distributed by logically centralized controller
- **OpenFlow**:
    + *flow*: defined by header fields
    + *pattern*: match values in packet header
    + *actions* for matched packet: drop, forward, modify, matched packet, send to controller
    + *priority*: disambiguate overlapping patterns
    + *counters*: nBytes, nPackets
    + **match+action** can replace multiple devices (router, firewall, switch, NAT)
